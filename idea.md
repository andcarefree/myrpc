# 关于项目设计的一些想法
***
## 关于调用接口的request与respond设计
1.protobuf个人感觉主要的特点在于跨语言。作为一个idl，只需要定义一份接口描述文件就可以根据文件生成不同代码的接口形式（类或结构体）。

2.想一想开发流程。首先是项目需要增加一个新功能，而且这个功能设计到两个服务模块的交互，也就是需要rpc调用。调用方需要一些数据
于是构建了自己需要的respond。而被调用方想要在本地调用函数的话，需要一些request入参，而这个request格式调用方一定需要知道否则无法发起调用。
\
那么从“必须这个角度来说”，双方构建代码之前对request格式是必须协商的，否则无法发起第一次交流（第一次交流也可以沟通request与respond格式？）

假定的双方构建代码之前的屏蔽是不需要的，因为从逻辑上来说，
需要新增的功能应该是双方首先协商，那么关于request与respond的格式应该也是事先协商而不需要在服务调用时运用一定的方式自解释。
\
我之前错误的想法在于，调用方接受的返回参数是一个空接口，就误以为不需要协商request与respond。之前误以为的流程中，是服务端***先实现一个方法***,而后客户端只需要知道request然后调用
这个方法。但是如果客户端都不知道自己需要什么respond，又为什么发起这一次远程调用呢？

所以关于接口的request与respond协商是必须的，就像web开发中前后端事先协商接口的json格式以及protobuf中实现编写一个定义接口request与respond的格式文件

3.那么myrpc现在这个设计就是完全错误的了：
调用方知道request并接受一个空接口respond发起调用，被调用方根据request中的方法名反射获得request与respond结构
（单说这里这一点的改进，可否在序列化中自解释获得request结构信息而不用反射？虽然感觉也很呆逼，毕竟反射和增大序列化结果长度导致网络传输信息增多都是性能瓶颈）

4.可以像protobuf那样在调用双方都维护一份相同的记录request与respond格式的文件，因为这个玩具项目不需要跨语言。
所以单纯维护request与respond结构体就可以了。
###接口兼容性问题
但是这样的问题是，如果服务方改进了服务函数导致request中返回字段增加，也会导致在调用方依赖该服务的地方改动
（即使之前的调用不需要新增字段，也就是说只需要上一个版本的服务函数）
>是否可以设计一种方式使得服务方兼容性升级时，只需要旧版本的客户端不需要跟着升级

>是否可以设计格式使得respond向前兼容？

前后端json的模式不存在这种问题，json只是作为一种信息集合。因为强制匹配调用双方request与respond结构体的原因是双方维护的信息格式**结构体**相同（如果不相同说明出现了多版本副本，更麻烦）。
如果升级了格式文件而不升级调用方的函数入参就会出现不匹配问题（好像也可以说旧字段赋值，新字段忽略。但是新字段为零值需要新版本的服务方没有奇怪的交互。这样看的话json也存在这样的问题，
毕竟信息的熵增加了可能存在奇怪的交互逻辑）

>接口双方的升级是否必须同步？如果需要的话就不用考虑向前兼容的问题

***

##关于TCP连接的思考

特定的客户端进程到服务端进程是否只需要一个TCP连接？关于call的分辨，可以像HTTP2.0那样给每一个call标识唯一id。
一个TCP连接应该是落实到协程对协程。一个server接收请求是串行化接收还是开协程并行处理？

作为服务方的模块肯定有很多暴露的rpc服务（就像web服务器暴露接口一样），
每一个暴露的rpc服务都可以只开一个协程检测连接请求，对于请求过来已建立的连接开协程处理（底层是io多路复用）。
这样看的话，每一个call都会有一个协程（一个协程一个TCP连接）。
但是从请求方来看，每一次调用都新开一个TCP连接肯定是不现实的。一定会有TCP保活复用的机制。
那么就是考虑是否需要TCP连接池的问题。
>多个TCP连接并行传输对于一个TCP连接串行传输的优势在哪儿？

从服务方来说这一切是透明的，因为go对io多路复用的包装,实际上服务方只需要处理每一个协程(TCP连接)上传来的call。
